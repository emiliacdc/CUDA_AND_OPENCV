# -*- coding: utf-8 -*-
"""NoteBook_Trabalho_CP

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FYaHspZaz3q1tJEr3oQJYBPGVDJH8kBa
"""

!nvcc --version

!apt-get --purge remove cuda nvidia* libnvidia-*
!dpkg -l | grep cuda- | awk '{print $2}' | xargs -n1 dpkg --purge
!apt-get remove cuda-*
!apt autoremove
!apt-get update

!wget https://developer.nvidia.com/compute/cuda/9.2/Prod/local_installers/cuda-repo-ubuntu1604-9-2-local_9.2.88-1_amd64 -O cuda-repo-ubuntu1604-9-2-local_9.2.88-1_amd64.deb
!dpkg -i cuda-repo-ubuntu1604-9-2-local_9.2.88-1_amd64.deb
!apt-key add /var/cuda-repo-9-2-local/7fa2af80.pub
!apt-get update
!apt-get install cuda-9.2

!nvcc --version
!pip install git+git://github.com/andreinechaev/nvcc4jupyter.git

# Commented out IPython magic to ensure Python compatibility.
# %load_ext nvcc_plugin

# Commented out IPython magic to ensure Python compatibility.
# %reload_ext nvcc_plugin

!apt-get -qq install -y libsm6 libxext6

!pip3 install tensorflow==1.14.0
!pip3 install keras
!pip3 install torch torchvision
!apt-get install python-numpy python-scipy

# Commented out IPython magic to ensure Python compatibility.
# %tensorflow_version 1.x
import tensorflow
print(tensorflow.__version__)

# Commented out IPython magic to ensure Python compatibility.
!apt-get install -qq gcc-5 g++-5 -y
!ln -s /usr/bin/gcc-5 
!ln -s /usr/bin/g++-5 

!sudo apt-get update
!sudo apt-get upgrade

#Install Dependencies
!sudo apt-get install -y build-essential 
!sudo apt-get install -y cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev
#The following command is needed to process images:
!sudo apt-get install -y python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev
#To process videos:
!sudo apt-get install -y libavcodec-dev libavformat-dev libswscale-dev libv4l-dev
!sudo apt-get install -y libxvidcore-dev libx264-dev
#For GUI:
!sudo apt-get install -y libgtk-3-dev
#For optimization:
!sudo apt-get install -y libatlas-base-dev gfortran pylint
!wget https://github.com/opencv/opencv/archive/3.4.0.zip -O opencv-3.4.0.zip
!sudo apt-get install unzip
!unzip opencv-3.4.0.zip
# %cd opencv-3.4.0
!mkdir build
# %cd build

"""Abra o arquivo /opencv-3.4.0/modules/python/src2/cv2.cpp e na linha 885 troque o texto de: char* str = PyString_AsString(obj);

Para o seguinte texto:
const char* str = PyString_AsString(obj);
"""

!cmake -D WITH_TBB=ON -D WITH_OPENMP=ON -D WITH_IPP=ON -D CMAKE_BUILD_TYPE=RELEASE -D BUILD_EXAMPLES=OFF -D WITH_NVCUVID=ON -D WITH_CUDA=ON -D WITH_CUBLAS=ON -D BUILD_DOCS=OFF -D BUILD_PERF_TESTS=OFF -D BUILD_TESTS=OFF -D WITH_CSTRIPES=ON -D WITH_OPENCL=ON CMAKE_INSTALL_PREFIX=/usr/local/ ..
!make -j`nproc`
!sudo make install

# Commented out IPython magic to ensure Python compatibility.
# %cd /etc/ld.so.conf.d/

# Commented out IPython magic to ensure Python compatibility.
# %%writefile opencv.conf
# /usr/local/lib
# /content/opencv-3.4.0/build/lib

# Commented out IPython magic to ensure Python compatibility.
# %%shell
# ldconfig

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/src/

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %%writefile test.cu
# #include <iostream>
# #include <ctime>
# #include <cmath>
# #include "bits/time.h"
# 
# #include <opencv2/opencv.hpp>
# #include <opencv2/core/core.hpp>
# #include <opencv2/highgui/highgui.hpp>
# #include <opencv2/imgproc/imgproc.hpp>
# #include <opencv2/imgcodecs/imgcodecs.hpp>
# 
# #include <opencv2/core/cuda.hpp>
# #include <opencv2/cudaimgproc.hpp>
# 
# #define TestCUDA true
# 
# int main()
# {
#     std::clock_t begin = std::clock();
# 
#     try {
#         cv::Mat srcHost = cv::imread("/content/drive/MyDrive/Imagens/i(0).jpg",CV_LOAD_IMAGE_GRAYSCALE);
# 
#         for(int i=0; i<1000; i++) {
#             if(TestCUDA) {
#                 cv::cuda::GpuMat dst, src;
#                 src.upload(srcHost);
# 
#                 //cv::cuda::threshold(src,dst,128.0,255.0, CV_THRESH_BINARY);
#                 cv::cuda::bilateralFilter(src,dst,3,1,1);
# 
#                 cv::Mat resultHost;
#                 dst.download(resultHost);
#             } else {
#                 cv::Mat dst;
#                 cv::bilateralFilter(srcHost,dst,3,1,1);
#             }
#         }
# 
#         //cv::imshow("Result",resultHost);
#         //cv::waitKey();
# 
#     } catch(const cv::Exception& ex) {
#         std::cout << "Error: " << ex.what() << std::endl;
#     }
# 
#     std::clock_t end = std::clock();
#     std::cout << double(end-begin) / CLOCKS_PER_SEC  << std::endl;
# }

# Commented out IPython magic to ensure Python compatibility.
# %%shell
# nvcc test.cu -L/usr/local/lib -o test.out  -I /content/src/opencv-3.4.0  -lm -lopencv_objdetect -lopencv_cudaarithm -lopencv_cudaimgproc -lopencv_features2d -lopencv_imgproc -lopencv_highgui -lopencv_core -lopencv_imgcodecs
# 
#

# Commented out IPython magic to ensure Python compatibility.
# %%writefile kmeans_imagem.cu
# 
#   
# #include <opencv2/core/cuda/common.hpp>
# #include <stdio.h>
# #include <string.h>
# #include <iostream>
# #include <assert.h>
# #include <sys/types.h>
# #include <sys/stat.h>
# #include <unistd.h>
# #include <opencv2/opencv.hpp>
# #include <cuda_runtime.h> 
# #include <opencv2/highgui.hpp>
# #include <opencv2/imgproc.hpp>
# #include <opencv2/calib3d/calib3d.hpp>
# #include <opencv2/core/core.hpp>
# #include <opencv2/core/cuda.hpp>
# 
# #include <opencv2/cudaimgproc.hpp>
# 
#  
# int main(){
#     cv::Mat img = cv::imread("/content/drive/MyDrive/Imagens/i(0).jpg", IMREAD_GRAYSCALE);
#     cv::cuda::GpuMat dst, src;
#     src.upload(img);
#     cv::Ptr<cv::cuda::CLAHE> ptr_clahe = cv::cuda::createCLAHE(5.0, cv::Size(8, 8));
#     ptr_clahe->apply(src, dst);
#     
#     cv::Mat result;
#     //dst.download(result);
# 
#     //cv::waitKey();
#     return 0;
# }

# Commented out IPython magic to ensure Python compatibility.
# %%shell
# nvcc kmeans_imagem.cu -L/usr/local/lib -o kmeans_imagem.out  -I /content/src/opencv-3.4.0  -lm -lopencv_cudaimgproc -lopencv_objdetect -lopencv_features2d -lopencv_imgproc -lopencv_highgui -lopencv_core -lopencv_imgcodecs
# 
# ./kmeans_imagem.out

# Commented out IPython magic to ensure Python compatibility.
# %%shell
# g++ kmeans_sequencial.cpp -L/usr/local/lib -o kmeans_sequencial.out  -I /content/src/opencv-3.4.0  -lm -lopencv_objdetect -lopencv_features2d -lopencv_imgproc -lopencv_highgui -lopencv_core -lopencv_imgcodecs
#

# Commented out IPython magic to ensure Python compatibility.
# %%shell
# ./kmeans_sequencial.out

# Commented out IPython magic to ensure Python compatibility.
# %%shell
# g++ kmeans.cpp -L/usr/local/lib -o kmeans.out  -I /content/src/opencv-3.4.0  -lm -lopencv_objdetect -lopencv_features2d -lopencv_imgproc -lopencv_highgui -lopencv_core -lopencv_imgcodecs
# 
# ./kmeans.out

import cv2
import numpy as np

import os
os.system('curl -O https://prod-images-static.radiopaedia.org/images/259710/b3163fb25a0dbcf470c0f827b9c468_gallery.jpg')

# Commented out IPython magic to ensure Python compatibility.
# %%writefile kmeans_teste.cpp
# #include "precomp.hpp"
# 
# #include "opencv2/highgui.hpp"
# #include "opencv2/core.hpp"
# #include "opencv2/imgproc.hpp"
# #include <iostream>
# using namespace cv;
# using namespace std;
# 
# // static void help()
# // {
# //     cout << "\nThis program demonstrates kmeans clustering.\n"
# //             "It generates an image with random points, then assigns a random number of cluster\n"
# //             "centers and uses kmeans to move those cluster centers to their representitive location\n"
# //             "Call\n"
# //             "./kmeans\n" << endl;
# // }
# int main( int /*argc*/, char** /*argv*/ )
# {
#     const int MAX_CLUSTERS = 5;
#     Scalar colorTab[] =
#     {
#         Scalar(0, 0, 255),
#         Scalar(0,255,0),
#         Scalar(255,100,100),
#         Scalar(255,0,255),
#         Scalar(0,255,255)
#     };
#     Mat img(500, 500, CV_8UC3);
#     RNG rng(12345);
#     for(;;)
#     {
#         int k, clusterCount = rng.uniform(2, MAX_CLUSTERS+1);
#         int i, sampleCount = rng.uniform(1, 1001);
#         Mat points(sampleCount, 1, CV_32FC2), labels;
# 
#         clusterCount = MIN(clusterCount, sampleCount);
#         Mat centers;
#         std::vector<Point2f> centers;
# 
#         /* generate random sample from multigaussian distribution */
#         for( k = 0; k < clusterCount; k++ )
#         {
#             Point center;
#             center.x = rng.uniform(0, img.cols);
#             center.y = rng.uniform(0, img.rows);
#             Mat pointChunk = points.rowRange(k*sampleCount/clusterCount,
#                                              k == clusterCount - 1 ? sampleCount :
#                                              (k+1)*sampleCount/clusterCount);
#             rng.fill(pointChunk, RNG::NORMAL, Scalar(center.x, center.y), Scalar(img.cols*0.05, img.rows*0.05));
#         }
#         randShuffle(points, 1, &rng);
#         double compactness = kmeans(points, clusterCount, labels,
#             TermCriteria( TermCriteria::EPS+TermCriteria::COUNT, 10, 1.0),
#                3, KMEANS_PP_CENTERS, centers);
#         img = Scalar::all(0);
#         for( i = 0; i < sampleCount; i++ )
#         {
#             int clusterIdx = labels.at<int>(i);
#             Point ipt = points.at<Point2f>(i);
#             circle( img, ipt, 2, colorTab[clusterIdx], FILLED, LINE_AA );
#         }
#         for (i = 0; i < centers.rows; ++i)
#         for (i = 0; i < (int)centers.size(); ++i)
#         {
#             Point2f c = centers.at<Point2f>(i);
#             Point2f c = centers[i];
#             circle( img, c, 40, colorTab[i], 1, LINE_AA );
#         }
#         cout << "Compactness: " << compactness << endl;
#         imshow("clusters", img);
#         char key = (char)waitKey();
#         if( key == 27 || key == 'q' || key == 'Q' ) // 'ESC'
#             break;
#     }
#     return 0;
# }
# 
# 
# ////////////////////////////////////////// kmeans ////////////////////////////////////////////
# namespace cv
# {
# static void generateRandomCenter(const std::vector<Vec2f>& box, float* center, RNG& rng)
# {
#     size_t j, dims = box.size();
#     float margin = 1.f/dims;
#     for( j = 0; j < dims; j++ )
#         center[j] = ((float)rng*(1.f+margin*2.f)-margin)*(box[j][1] - box[j][0]) + box[j][0];
# }
# class KMeansPPDistanceComputer : public ParallelLoopBody
# {
# public:
#     KMeansPPDistanceComputer( float *_tdist2,
#                               const float *_data,
#                               const float *_dist,
#                               int _dims,
#                               size_t _step,
#                               size_t _stepci )
#         : tdist2(_tdist2),
#           data(_data),
#           dist(_dist),
#           dims(_dims),
#           step(_step),
#           stepci(_stepci) { }
#     void operator()( const cv::Range& range ) const
#     {
#         CV_TRACE_FUNCTION();
#         const int begin = range.start;
#         const int end = range.end;
#         for ( int i = begin; i<end; i++ )
#         {
#             tdist2[i] = std::min(normL2Sqr(data + step*i, data + stepci, dims), dist[i]);
#         }
#     }
# private:
#     KMeansPPDistanceComputer& operator=(const KMeansPPDistanceComputer&); // to quiet MSVC
#     float *tdist2;
#     const float *data;
#     const float *dist;
#     const int dims;
#     const size_t step;
#     const size_t stepci;
# };
# /*
# k-means center initialization using the following algorithm:
# Arthur & Vassilvitskii (2007) k-means++: The Advantages of Careful Seeding
# */
# static void generateCentersPP(const Mat& _data, Mat& _out_centers,
#                               int K, RNG& rng, int trials)
# {
#     CV_TRACE_FUNCTION();
#     int i, j, k, dims = _data.cols, N = _data.rows;
#     const float* data = _data.ptr<float>(0);
#     size_t step = _data.step/sizeof(data[0]);
#     std::vector<int> _centers(K);
#     int* centers = &_centers[0];
#     std::vector<float> _dist(N*3);
#     float* dist = &_dist[0], *tdist = dist + N, *tdist2 = tdist + N;
#     double sum0 = 0;
#     centers[0] = (unsigned)rng % N;
#     for( i = 0; i < N; i++ )
#     {
#         dist[i] = normL2Sqr(data + step*i, data + step*centers[0], dims);
#         sum0 += dist[i];
#     }
#     for( k = 1; k < K; k++ )
#     {
#         double bestSum = DBL_MAX;
#         int bestCenter = -1;
#         for( j = 0; j < trials; j++ )
#         {
#             double p = (double)rng*sum0, s = 0;
#             for( i = 0; i < N-1; i++ )
#                 if( (p -= dist[i]) <= 0 )
#                     break;
#             int ci = i;
#             parallel_for_(Range(0, N),
#                          KMeansPPDistanceComputer(tdist2, data, dist, dims, step, step*ci));
#             for( i = 0; i < N; i++ )
#             {
#                 s += tdist2[i];
#             }
#             if( s < bestSum )
#             {
#                 bestSum = s;
#                 bestCenter = ci;
#                 std::swap(tdist, tdist2);
#             }
#         }
#         centers[k] = bestCenter;
#         sum0 = bestSum;
#         std::swap(dist, tdist);
#     }
#     for( k = 0; k < K; k++ )
#     {
#         const float* src = data + step*centers[k];
#         float* dst = _out_centers.ptr<float>(k);
#         for( j = 0; j < dims; j++ )
#             dst[j] = src[j];
#     }
# }
# class KMeansDistanceComputer : public ParallelLoopBody
# {
# public:
#     KMeansDistanceComputer( double *_distances,
#                             int *_labels,
#                             const Mat& _data,
#                             const Mat& _centers,
#                             bool _onlyDistance = false )
#         : distances(_distances),
#           labels(_labels),
#           data(_data),
#           centers(_centers),
#           onlyDistance(_onlyDistance)
#     {
#     }
#     void operator()( const Range& range ) const
#     {
#         const int begin = range.start;
#         const int end = range.end;
#         const int K = centers.rows;
#         const int dims = centers.cols;
#         for( int i = begin; i<end; ++i)
#         {
#             const float *sample = data.ptr<float>(i);
#             if (onlyDistance)
#             {
#                 const float* center = centers.ptr<float>(labels[i]);
#                 distances[i] = normL2Sqr(sample, center, dims);
#                 continue;
#             }
#             int k_best = 0;
#             double min_dist = DBL_MAX;
#             for( int k = 0; k < K; k++ )
#             {
#                 const float* center = centers.ptr<float>(k);
#                 const double dist = normL2Sqr(sample, center, dims);
#                 if( min_dist > dist )
#                 {
#                     min_dist = dist;
#                     k_best = k;
#                 }
#             }
#             distances[i] = min_dist;
#             labels[i] = k_best;
#         }
#     }
# private:
#     KMeansDistanceComputer& operator=(const KMeansDistanceComputer&); // to quiet MSVC
#     double *distances;
#     int *labels;
#     const Mat& data;
#     const Mat& centers;
#     bool onlyDistance;
# };
# }
# 
# 
# double cv::kmeans( InputArray _data, int K,
#                    InputOutputArray _bestLabels,
#                    TermCriteria criteria, int attempts,
#                    int flags, OutputArray _centers )
# {
#     CV_INSTRUMENT_REGION()
#     const int SPP_TRIALS = 3;
#     Mat data0 = _data.getMat();
#     bool isrow = data0.rows == 1;
#     int N = isrow ? data0.cols : data0.rows;
#     int dims = (isrow ? 1 : data0.cols)*data0.channels();
#     int type = data0.depth();
#     attempts = std::max(attempts, 1);
#     CV_Assert( data0.dims <= 2 && type == CV_32F && K > 0 );
#     CV_Assert( N >= K );
#     Mat data(N, dims, CV_32F, data0.ptr(), isrow ? dims * sizeof(float) : static_cast<size_t>(data0.step));
#     _bestLabels.create(N, 1, CV_32S, -1, true);
#     Mat _labels, best_labels = _bestLabels.getMat();
#     if( flags & CV_KMEANS_USE_INITIAL_LABELS )
#     {
#         CV_Assert( (best_labels.cols == 1 || best_labels.rows == 1) &&
#                   best_labels.cols*best_labels.rows == N &&
#                   best_labels.type() == CV_32S &&
#                   best_labels.isContinuous());
#         best_labels.copyTo(_labels);
#     }
#     else
#     {
#         if( !((best_labels.cols == 1 || best_labels.rows == 1) &&
#              best_labels.cols*best_labels.rows == N &&
#             best_labels.type() == CV_32S &&
#             best_labels.isContinuous()))
#             best_labels.create(N, 1, CV_32S);
#         _labels.create(best_labels.size(), best_labels.type());
#     }
#     int* labels = _labels.ptr<int>();
#     Mat centers(K, dims, type), old_centers(K, dims, type), temp(1, dims, type);
#     std::vector<int> counters(K);
#     std::vector<Vec2f> _box(dims);
#     Mat dists(1, N, CV_64F);
#     Vec2f* box = &_box[0];
#     double best_compactness = DBL_MAX, compactness = 0;
#     RNG& rng = theRNG();
#     int a, iter, i, j, k;
#     if( criteria.type & TermCriteria::EPS )
#         criteria.epsilon = std::max(criteria.epsilon, 0.);
#     else
#         criteria.epsilon = FLT_EPSILON;
#     criteria.epsilon *= criteria.epsilon;
#     if( criteria.type & TermCriteria::COUNT )
#         criteria.maxCount = std::min(std::max(criteria.maxCount, 2), 100);
#     else
#         criteria.maxCount = 100;
#     if( K == 1 )
#     {
#         attempts = 1;
#         criteria.maxCount = 2;
#     }
#     const float* sample = data.ptr<float>(0);
#     for( j = 0; j < dims; j++ )
#         box[j] = Vec2f(sample[j], sample[j]);
#     for( i = 1; i < N; i++ )
#     {
#         sample = data.ptr<float>(i);
#         for( j = 0; j < dims; j++ )
#         {
#             float v = sample[j];
#             box[j][0] = std::min(box[j][0], v);
#             box[j][1] = std::max(box[j][1], v);
#         }
#     }
#     for( a = 0; a < attempts; a++ )
#     {
#         double max_center_shift = DBL_MAX;
#         for( iter = 0;; )
#         {
#             swap(centers, old_centers);
#             if( iter == 0 && (a > 0 || !(flags & KMEANS_USE_INITIAL_LABELS)) )
#             {
#                 if( flags & KMEANS_PP_CENTERS )
#                     generateCentersPP(data, centers, K, rng, SPP_TRIALS);
#                 else
#                 {
#                     for( k = 0; k < K; k++ )
#                         generateRandomCenter(_box, centers.ptr<float>(k), rng);
#                 }
#             }
#             else
#             {
#                 if( iter == 0 && a == 0 && (flags & KMEANS_USE_INITIAL_LABELS) )
#                 {
#                     for( i = 0; i < N; i++ )
#                         CV_Assert( (unsigned)labels[i] < (unsigned)K );
#                 }
#                 // compute centers
#                 centers = Scalar(0);
#                 for( k = 0; k < K; k++ )
#                     counters[k] = 0;
#                 for( i = 0; i < N; i++ )
#                 {
#                     sample = data.ptr<float>(i);
#                     k = labels[i];
#                     float* center = centers.ptr<float>(k);
#                     j=0;
#                     #if CV_ENABLE_UNROLLED
#                     for(; j <= dims - 4; j += 4 )
#                     {
#                         float t0 = center[j] + sample[j];
#                         float t1 = center[j+1] + sample[j+1];
#                         center[j] = t0;
#                         center[j+1] = t1;
#                         t0 = center[j+2] + sample[j+2];
#                         t1 = center[j+3] + sample[j+3];
#                         center[j+2] = t0;
#                         center[j+3] = t1;
#                     }
#                     #endif
#                     for( ; j < dims; j++ )
#                         center[j] += sample[j];
#                     counters[k]++;
#                 }
#                 if( iter > 0 )
#                     max_center_shift = 0;
#                 for( k = 0; k < K; k++ )
#                 {
#                     if( counters[k] != 0 )
#                         continue;
#                     // if some cluster appeared to be empty then:
#                     //   1. find the biggest cluster
#                     //   2. find the farthest from the center point in the biggest cluster
#                     //   3. exclude the farthest point from the biggest cluster and form a new 1-point cluster.
#                     int max_k = 0;
#                     for( int k1 = 1; k1 < K; k1++ )
#                     {
#                         if( counters[max_k] < counters[k1] )
#                             max_k = k1;
#                     }
#                     double max_dist = 0;
#                     int farthest_i = -1;
#                     float* new_center = centers.ptr<float>(k);
#                     float* old_center = centers.ptr<float>(max_k);
#                     float* _old_center = temp.ptr<float>(); // normalized
#                     float scale = 1.f/counters[max_k];
#                     for( j = 0; j < dims; j++ )
#                         _old_center[j] = old_center[j]*scale;
#                     for( i = 0; i < N; i++ )
#                     {
#                         if( labels[i] != max_k )
#                             continue;
#                         sample = data.ptr<float>(i);
#                         double dist = normL2Sqr(sample, _old_center, dims);
#                         if( max_dist <= dist )
#                         {
#                             max_dist = dist;
#                             farthest_i = i;
#                         }
#                     }
#                     counters[max_k]--;
#                     counters[k]++;
#                     labels[farthest_i] = k;
#                     sample = data.ptr<float>(farthest_i);
#                     for( j = 0; j < dims; j++ )
#                     {
#                         old_center[j] -= sample[j];
#                         new_center[j] += sample[j];
#                     }
#                 }
#                 for( k = 0; k < K; k++ )
#                 {
#                     float* center = centers.ptr<float>(k);
#                     CV_Assert( counters[k] != 0 );
#                     float scale = 1.f/counters[k];
#                     for( j = 0; j < dims; j++ )
#                         center[j] *= scale;
#                     if( iter > 0 )
#                     {
#                         double dist = 0;
#                         const float* old_center = old_centers.ptr<float>(k);
#                         for( j = 0; j < dims; j++ )
#                         {
#                             double t = center[j] - old_center[j];
#                             dist += t*t;
#                         }
#                         max_center_shift = std::max(max_center_shift, dist);
#                     }
#                 }
#             }
#             bool isLastIter = (++iter == MAX(criteria.maxCount, 2) || max_center_shift <= criteria.epsilon);
#             // assign labels
#             dists = 0;
#             double* dist = dists.ptr<double>(0);
#             parallel_for_(Range(0, N), KMeansDistanceComputer(dist, labels, data, centers, isLastIter));
#             compactness = sum(dists)[0];
#             if (isLastIter)
#                 break;
#         }
#         if( compactness < best_compactness )
#         {
#             best_compactness = compactness;
#             if( _centers.needed() )
#                 centers.copyTo(_centers);
#             {
#                 Mat reshaped = centers;
#                 if(_centers.fixedType() && _centers.channels() == dims)
#                     reshaped = centers.reshape(dims);
#                 reshaped.copyTo(_centers);
#             }
#             _labels.copyTo(best_labels);
#         }
#     }
#     return best_compactness;
# }
#

# Commented out IPython magic to ensure Python compatibility.
# %%shell
# g++ kmeans_teste.cpp -L/usr/local/lib -o kmeans_teste.out  -I /content/src/opencv-3.4.0  -lm -lopencv_objdetect -lopencv_features2d -lopencv_imgproc -lopencv_highgui -lopencv_core -lopencv_imgcodecs
#

//----------------------Codigo do kmeans que é chamado-------------------------------
double cv::kmeans_imag( InputArray _data, int K,
                   InputOutputArray _bestLabels,
                   TermCriteria criteria, int attempts,
                   int flags, OutputArray _centers )
{
    CV_INSTRUMENT_REGION()
    const int SPP_TRIALS = 3;
    Mat data0 = _data.getMat();
    bool isrow = data0.rows == 1;
    int N = isrow ? data0.cols : data0.rows;
    int dims = (isrow ? 1 : data0.cols)*data0.channels();
    int type = data0.depth();
    attempts = std::max(attempts, 1);
    CV_Assert( data0.dims <= 2 && type == CV_32F && K > 0 );
    CV_Assert( N >= K );
    Mat data(N, dims, CV_32F, data0.ptr(), isrow ? dims * sizeof(float) : static_cast<size_t>(data0.step));
    _bestLabels.create(N, 1, CV_32S, -1, true);
    Mat _labels, best_labels = _bestLabels.getMat();
    if( flags & CV_KMEANS_USE_INITIAL_LABELS )
    {
        CV_Assert( (best_labels.cols == 1 || best_labels.rows == 1) &&
                  best_labels.cols*best_labels.rows == N &&
                  best_labels.type() == CV_32S &&
                  best_labels.isContinuous());
        best_labels.copyTo(_labels);
    }
    else
    {
        if( !((best_labels.cols == 1 || best_labels.rows == 1) &&
             best_labels.cols*best_labels.rows == N &&
            best_labels.type() == CV_32S &&
            best_labels.isContinuous()))
            best_labels.create(N, 1, CV_32S);
        _labels.create(best_labels.size(), best_labels.type());
    }
    int* labels = _labels.ptr<int>();
    Mat centers(K, dims, type), old_centers(K, dims, type), temp(1, dims, type);
    std::vector<int> counters(K);
    std::vector<Vec2f> _box(dims);
    Mat dists(1, N, CV_64F);
    Vec2f* box = &_box[0];
    double best_compactness = DBL_MAX, compactness = 0;
    RNG& rng = theRNG();
    int a, iter, i, j, k;
    if( criteria.type & TermCriteria::EPS )
        criteria.epsilon = std::max(criteria.epsilon, 0.);
    else
        criteria.epsilon = FLT_EPSILON;
    criteria.epsilon *= criteria.epsilon;
    if( criteria.type & TermCriteria::COUNT )
        criteria.maxCount = std::min(std::max(criteria.maxCount, 2), 100);
    else
        criteria.maxCount = 100;
    if( K == 1 )
    {
        attempts = 1;
        criteria.maxCount = 2;
    }
    const float* sample = data.ptr<float>(0);
    for( j = 0; j < dims; j++ )
        box[j] = Vec2f(sample[j], sample[j]);
    for( i = 1; i < N; i++ )
    {
        sample = data.ptr<float>(i);
        for( j = 0; j < dims; j++ )
        {
            float v = sample[j];
            box[j][0] = std::min(box[j][0], v);
            box[j][1] = std::max(box[j][1], v);
        }
    }
    for( a = 0; a < attempts; a++ )
    {
        double max_center_shift = DBL_MAX;
        for( iter = 0;; )
        {
            swap(centers, old_centers);
            if( iter == 0 && (a > 0 || !(flags & KMEANS_USE_INITIAL_LABELS)) )
            {
                if( flags & KMEANS_PP_CENTERS )
                    generateCentersPP(data, centers, K, rng, SPP_TRIALS);
                else
                {
                    for( k = 0; k < K; k++ )
                        generateRandomCenter(_box, centers.ptr<float>(k), rng);
                }
            }
            else
            {
                if( iter == 0 && a == 0 && (flags & KMEANS_USE_INITIAL_LABELS) )
                {
                    for( i = 0; i < N; i++ )
                        CV_Assert( (unsigned)labels[i] < (unsigned)K );
                }
                // compute centers
                centers = Scalar(0);
                for( k = 0; k < K; k++ )
                    counters[k] = 0;
                for( i = 0; i < N; i++ )
                {
                    sample = data.ptr<float>(i);
                    k = labels[i];
                    float* center = centers.ptr<float>(k);
                    j=0;
                    #if CV_ENABLE_UNROLLED
                    for(; j <= dims - 4; j += 4 )
                    {
                        float t0 = center[j] + sample[j];
                        float t1 = center[j+1] + sample[j+1];
                        center[j] = t0;
                        center[j+1] = t1;
                        t0 = center[j+2] + sample[j+2];
                        t1 = center[j+3] + sample[j+3];
                        center[j+2] = t0;
                        center[j+3] = t1;
                    }
                    #endif
                    for( ; j < dims; j++ )
                        center[j] += sample[j];
                    counters[k]++;
                }
                if( iter > 0 )
                    max_center_shift = 0;
                for( k = 0; k < K; k++ )
                {
                    if( counters[k] != 0 )
                        continue;
                    // if some cluster appeared to be empty then:
                    //   1. find the biggest cluster
                    //   2. find the farthest from the center point in the biggest cluster
                    //   3. exclude the farthest point from the biggest cluster and form a new 1-point cluster.
                    int max_k = 0;
                    for( int k1 = 1; k1 < K; k1++ )
                    {
                        if( counters[max_k] < counters[k1] )
                            max_k = k1;
                    }
                    double max_dist = 0;
                    int farthest_i = -1;
                    float* new_center = centers.ptr<float>(k);
                    float* old_center = centers.ptr<float>(max_k);
                    float* _old_center = temp.ptr<float>(); // normalized
                    float scale = 1.f/counters[max_k];
                    for( j = 0; j < dims; j++ )
                        _old_center[j] = old_center[j]*scale;
                    for( i = 0; i < N; i++ )
                    {
                        if( labels[i] != max_k )
                            continue;
                        sample = data.ptr<float>(i);
                        double dist = normL2Sqr(sample, _old_center, dims);
                        if( max_dist <= dist )
                        {
                            max_dist = dist;
                            farthest_i = i;
                        }
                    }
                    counters[max_k]--;
                    counters[k]++;
                    labels[farthest_i] = k;
                    sample = data.ptr<float>(farthest_i);
                    for( j = 0; j < dims; j++ )
                    {
                        old_center[j] -= sample[j];
                        new_center[j] += sample[j];
                    }
                }
                for( k = 0; k < K; k++ )
                {
                    float* center = centers.ptr<float>(k);
                    CV_Assert( counters[k] != 0 );
                    float scale = 1.f/counters[k];
                    for( j = 0; j < dims; j++ )
                        center[j] *= scale;
                    if( iter > 0 )
                    {
                        double dist = 0;
                        const float* old_center = old_centers.ptr<float>(k);
                        for( j = 0; j < dims; j++ )
                        {
                            double t = center[j] - old_center[j];
                            dist += t*t;
                        }
                        max_center_shift = std::max(max_center_shift, dist);
                    }
                }
            }
            bool isLastIter = (++iter == MAX(criteria.maxCount, 2) || max_center_shift <= criteria.epsilon);
            // assign labels
            dists = 0;
            double* dist = dists.ptr<double>(0);
            parallel_for_(Range(0, N), KMeansDistanceComputer(dist, labels, data, centers, isLastIter));
            compactness = sum(dists)[0];
            if (isLastIter)
                break;
        }
        if( compactness < best_compactness )
        {
            best_compactness = compactness;
            if( _centers.needed() )
                centers.copyTo(_centers);
            {
                Mat reshaped = centers;
                if(_centers.fixedType() && _centers.channels() == dims)
                    reshaped = centers.reshape(dims);
                reshaped.copyTo(_centers);
            }
            _labels.copyTo(best_labels);
        }
    }
    return best_compactness;
}

# Commented out IPython magic to ensure Python compatibility.
# %%writefile kmeans.cpp
# #include <iostream>
# #include <vector>
# #include <math.h>
# #include <stdlib.h>
# #include <time.h>
# #include <algorithm>
# 
# using namespace std;
# 
# class Point
# {
# private:
# 	int id_point, id_cluster;
# 	vector<double> values;
# 	int total_values;
# 	string name;
# 
# public:
# 	Point(int id_point, vector<double>& values, string name = "")
# 	{
# 		this->id_point = id_point;
# 		total_values = values.size();
# 
# 		for(int i = 0; i < total_values; i++)
# 			this->values.push_back(values[i]);
# 
# 		this->name = name;
# 		id_cluster = -1;
# 	}
# 
# 	int getID()
# 	{
# 		return id_point;
# 	}
# 
# 	void setCluster(int id_cluster)
# 	{
# 		this->id_cluster = id_cluster;
# 	}
# 
# 	int getCluster()
# 	{
# 		return id_cluster;
# 	}
# 
# 	double getValue(int index)
# 	{
# 		return values[index];
# 	}
# 
# 	int getTotalValues()
# 	{
# 		return total_values;
# 	}
# 
# 	void addValue(double value)
# 	{
# 		values.push_back(value);
# 	}
# 
# 	string getName()
# 	{
# 		return name;
# 	}
# };
# 
# class Cluster
# {
# private:
# 	int id_cluster;
# 	vector<double> central_values;
# 	vector<Point> points;
# 
# public:
# 	Cluster(int id_cluster, Point point)
# 	{
# 		this->id_cluster = id_cluster;
# 
# 		int total_values = point.getTotalValues();
# 
# 		for(int i = 0; i < total_values; i++)
# 			central_values.push_back(point.getValue(i));
# 
# 		points.push_back(point);
# 	}
# 
# 	void addPoint(Point point)
# 	{
# 		points.push_back(point);
# 	}
# 
# 	bool removePoint(int id_point)
# 	{
# 		int total_points = points.size();
# 
# 		for(int i = 0; i < total_points; i++)
# 		{
# 			if(points[i].getID() == id_point)
# 			{
# 				points.erase(points.begin() + i);
# 				return true;
# 			}
# 		}
# 		return false;
# 	}
# 
# 	double getCentralValue(int index)
# 	{
# 		return central_values[index];
# 	}
# 
# 	void setCentralValue(int index, double value)
# 	{
# 		central_values[index] = value;
# 	}
# 
# 	Point getPoint(int index)
# 	{
# 		return points[index];
# 	}
# 
# 	int getTotalPoints()
# 	{
# 		return points.size();
# 	}
# 
# 	int getID()
# 	{
# 		return id_cluster;
# 	}
# };
# 
# class KMeans
# {
# private:
# 	int K; // number of clusters
# 	int total_values, total_points, max_iterations;
# 	vector<Cluster> clusters;
# 
# 	// return ID of nearest center (uses euclidean distance)
# 	int getIDNearestCenter(Point point)
# 	{
# 		double sum = 0.0, min_dist;
# 		int id_cluster_center = 0;
# 
# 		for(int i = 0; i < total_values; i++)
# 		{
# 			sum += pow(clusters[0].getCentralValue(i) -
# 					   point.getValue(i), 2.0);
# 		}
# 
# 		min_dist = sqrt(sum);
# 
# 		for(int i = 1; i < K; i++)
# 		{
# 			double dist;
# 			sum = 0.0;
# 
# 			for(int j = 0; j < total_values; j++)
# 			{
# 				sum += pow(clusters[i].getCentralValue(j) -
# 						   point.getValue(j), 2.0);
# 			}
# 
# 			dist = sqrt(sum);
# 
# 			if(dist < min_dist)
# 			{
# 				min_dist = dist;
# 				id_cluster_center = i;
# 			}
# 		}
# 
# 		return id_cluster_center;
# 	}
# 
# public:
# 	KMeans(int K, int total_points, int total_values, int max_iterations)
# 	{
# 		this->K = K;
# 		this->total_points = total_points;
# 		this->total_values = total_values;
# 		this->max_iterations = max_iterations;
# 	}
# 
# 	void run(vector<Point> & points)
# 	{
# 		if(K > total_points)
# 			return;
# 
# 		vector<int> prohibited_indexes;
# 
# 		// choose K distinct values for the centers of the clusters
# 		for(int i = 0; i < K; i++)
# 		{
# 			while(true)
# 			{
# 				int index_point = rand() % total_points;
# 
# 				if(find(prohibited_indexes.begin(), prohibited_indexes.end(),
# 						index_point) == prohibited_indexes.end())
# 				{
# 					prohibited_indexes.push_back(index_point);
# 					points[index_point].setCluster(i);
# 					Cluster cluster(i, points[index_point]);
# 					clusters.push_back(cluster);
# 					break;
# 				}
# 			}
# 		}
# 
# 		int iter = 1;
# 
# 		while(true)
# 		{
# 			bool done = true;
# 
# 			// associates each point to the nearest center
# 			for(int i = 0; i < total_points; i++)
# 			{
# 				int id_old_cluster = points[i].getCluster();
# 				int id_nearest_center = getIDNearestCenter(points[i]);
# 
# 				if(id_old_cluster != id_nearest_center)
# 				{
# 					if(id_old_cluster != -1)
# 						clusters[id_old_cluster].removePoint(points[i].getID());
# 
# 					points[i].setCluster(id_nearest_center);
# 					clusters[id_nearest_center].addPoint(points[i]);
# 					done = false;
# 				}
# 			}
# 
# 			// recalculating the center of each cluster
# 			for(int i = 0; i < K; i++)
# 			{
# 				for(int j = 0; j < total_values; j++)
# 				{
# 					int total_points_cluster = clusters[i].getTotalPoints();
# 					double sum = 0.0;
# 
# 					if(total_points_cluster > 0)
# 					{
# 						for(int p = 0; p < total_points_cluster; p++)
# 							sum += clusters[i].getPoint(p).getValue(j);
# 						clusters[i].setCentralValue(j, sum / total_points_cluster);
# 					}
# 				}
# 			}
# 
# 			if(done == true || iter >= max_iterations)
# 			{
# 				cout << "Break in iteration " << iter << "\n\n";
# 				break;
# 			}
# 
# 			iter++;
# 		}
# 
# 		// shows elements of clusters
# 		for(int i = 0; i < K; i++)
# 		{
# 			int total_points_cluster =  clusters[i].getTotalPoints();
# 
# 			cout << "Cluster " << clusters[i].getID() + 1 << endl;
# 			for(int j = 0; j < total_points_cluster; j++)
# 			{
# 				cout << "Point " << clusters[i].getPoint(j).getID() + 1 << ": ";
# 				for(int p = 0; p < total_values; p++)
# 					cout << clusters[i].getPoint(j).getValue(p) << " ";
# 
# 				string point_name = clusters[i].getPoint(j).getName();
# 
# 				if(point_name != "")
# 					cout << "- " << point_name;
# 
# 				cout << endl;
# 			}
# 
# 			cout << "Cluster values: ";
# 
# 			for(int j = 0; j < total_values; j++)
# 				cout << clusters[i].getCentralValue(j) << " ";
# 
# 			cout << "\n\n";
# 		}
# 	}
# };
# 
# int main(int argc, char *argv[])
# {
# 	srand (time(NULL));
# 
# 	int total_points, total_values, K, max_iterations, has_name;
# 
# 	cin >> total_points >> total_values >> K >> max_iterations >> has_name;
# 
# 	vector<Point> points;
# 	string point_name;
# 
# 	for(int i = 0; i < total_points; i++)
# 	{
# 		vector<double> values;
# 
# 		for(int j = 0; j < total_values; j++)
# 		{
# 			double value;
# 			cin >> value;
# 			values.push_back(value);
# 		}
# 
# 		if(has_name)
# 		{
# 			cin >> point_name;
# 			Point p(i, values, point_name);
# 			points.push_back(p);
# 		}
# 		else
# 		{
# 			Point p(i, values);
# 			points.push_back(p);
# 		}
# 	}
# 
# 	KMeans kmeans(K, total_points, total_values, max_iterations);
# 	kmeans.run(points);
# 
# 	return 0;
# }